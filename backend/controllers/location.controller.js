// getRentalById	RÃ©cupÃ©rer une location spÃ©cifique	GET	/api/rentals/:id
// getUserRentals	RÃ©cupÃ©rer les locations dâ€™un utilisateur (locataire)	GET	/api/rentals/user/:userId
// getOwnerRentals	RÃ©cupÃ©rer les locations des vÃ©hicules dâ€™un propriÃ©taire	GET	/api/rentals/owner/:ownerId
// updateRentalStatus	Modifier le statut dâ€™une location (en attente, confirmÃ©e, terminÃ©e, annulÃ©e)	PUT	/api/rentals/:id/status
// cancelRental	Annuler une location	PUT	/api/rentals/:id/cancel
// deleteRental	Supprimer une location (admin uniquement)	DELETE	/api/rentals/:id

import AppError from "../utils/appError.js";
import catchAsync from "../utils/catchAsync.js";

import { Voiture } from "./../models/voiture.model.js";
import Location from "./../models/location.model.js";
import { Annonce } from "../models/annonce.model.js";

// creer une nouvelle location
// export const creerLocation = catchAsync(async (req, res, next) => {
//   const {
//     voiture: voitureId,
//     dateDebut,
//     dateFin,
//     lieuDepart,
//     lieuRetour,
//   } = req.body;

//   const voiture = await Voiture.findById(voitureId);
//   if (!voiture) return next(new AppError("Voiture non trouvÃ©"));

//   // Extraire l'ID de l'utilisateur depuis req.user
//   const userId = req.user._id;
//   console.log(userId);

//   // calculer la durÃ©e de la location en jours
//   const debut = new Date(dateDebut);
//   const fin = new Date(dateFin);
//   const diffTime = Math.abs(fin.getTime() - debut.getTime());

//   const nbrJours = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

//   // calcul du cout total
//   let coutTotal = nbrJours * voiture.tarifParJour;

//   const location = await Location.create({
//     voiture: voiture._id,
//     locataire: userId,
//     dateDebut: debut,
//     dateFin: fin,
//     status: "en attente",
//     lieuDepart,
//     lieuRetour,
//     coutTotal,
//     proprietaire: voiture.proprietaire,
//   });

//   res.status(201).json({
//     status: "succes",
//     data: location,
//   });
// });

// POST /api/locations
// export const creerDemandeLocation = catchAsync(async (req, res, next) => {
//   const { annonceId, dateDebut, dateFin } = req.body;
//   const annonce = await Annonce.findById(annonceId).populate("voiture");

//   if (!annonce || annonce.statut !== "actif") {
//     return next(new AppError("Annonce invalide ou dÃ©sactivÃ©e", 400));
//   }

//   const montant = calculerMontantTotal(
//     annonce.voiture.tarifParJour,
//     new Date(dateDebut),
//     new Date(dateFin)
//   );

//   const location = await Location.create({
//     annonce: annonceId,
//     locataire: req.user._id,
//     dateDebut: new Date(dateDebut),
//     dateFin: new Date(dateFin),

//     montantTotal: montant,
//   });

//   res.status(201).json({
//     status: "succÃ¨s",
//     data: location,
//   });
// });

import { isValid, parseISO } from "date-fns";

// faire une demande de locationğŸŸ¦
export const creerDemandeLocation = catchAsync(async (req, res, next) => {
  const { annonceId, dateDebut, dateFin, adresseDepot, adresseRetrait } =
    req.body;

  const annonce = await Annonce.findById(annonceId).populate("voiture");

  if (!annonce || annonce.statut !== "disponible") {
    return next(new AppError("Annonce invalide ou dÃ©sactivÃ©e", 400));
  }

  // ğŸ”’ Parse et valide les dates
  const parsedStart = new Date(dateDebut);
  const parsedEnd = new Date(dateFin);

  if (isNaN(parsedStart) || isNaN(parsedEnd)) {
    return next(
      new AppError("Dates invalides. Format attendu : YYYY-MM-DD", 400)
    );
  }

  // â›” DÃ©but aprÃ¨s fin
  if (parsedStart >= parsedEnd) {
    return next(
      new AppError("La date de dÃ©but doit Ãªtre avant la date de fin", 400)
    );
  }

  // âœ… VÃ©rifie si la rÃ©servation est dans la pÃ©riode de l'annonce
  if (parsedStart < annonce.dateDebut || parsedEnd > annonce.dateFin) {
    return next(
      new AppError(
        "Les dates de rÃ©servation doivent Ãªtre dans la pÃ©riode de l'annonce",
        400
      )
    );
  }

  const montant = calculerMontantTotal(
    annonce.voiture.tarifParJour,
    parsedStart,
    parsedEnd
  );

  const location = await Location.create({
    annonce: annonceId,
    locataire: req.user._id,
    dateDebut: parsedStart,
    dateFin: parsedEnd,
    montantTotal: montant,
    adresseDepot,
    adresseRetrait,
  });

 

  res.status(201).json({
    status: "succÃ¨s",
    data: location,
  });
});





function calculerMontantTotal(tarif, debut, fin) {
  const nbJours = Math.ceil((fin - debut) / (1000 * 60 * 60 * 24));
  return nbJours * tarif;
}

// GET /api/locations/mes-demandes ğŸŸ¦
export const listerDemandesProprio = catchAsync(async (req, res, next) => {
  const annonces = await Annonce.find({ proprietaire: req.user._id });
  const ids = annonces.map((a) => a._id);

  const demandes = await Location.find({ annonce: { $in: ids } })
    .populate("locataire")
    .populate({
      path: "annonce",
      populate: { path: "voiture" },
    });

  res.status(200).json({
    status: "ok",
    resultats: demandes.length,
    data: demandes,
  });
});

// PATCH /api/locations/:id
// export const traiterDemandeLocation = catchAsync(async (req, res, next) => {
//   const location = await Location.findById(req.params.id).populate("annonce");

//   if (
//     !location ||
//     location.annonce.proprietaire.toString() !== req.user._id.toString()
//   ) {
//     return next(new AppError("AccÃ¨s non autorisÃ©", 403));
//   }

//   location.statut = req.body.action === "accepter" ? "acceptee" : "refusee";
//   await location.save();

//     annonce.statut = "reserve";
//    await annonce.save();

//   res.status(200).json({ status: "succÃ¨s", data: location });
// });


// PATCH /api/locations/:id
export const traiterDemandeLocation = catchAsync(async (req, res, next) => {
  const location = await Location.findById(req.params.id).populate("annonce");

  if (
    !location ||
    location.annonce.proprietaire.toString() !== req.user._id.toString()
  ) {
    return next(new AppError("AccÃ¨s non autorisÃ©", 403));
  }

  const action = req.body.action;

  // Mettre Ã  jour le statut de la demande
  location.statut = action === "accepter" ? "acceptee" : "refusee";
  await location.save();

  // Si acceptÃ©, mettre aussi Ã  jour le statut de l'annonce Ã  "reserve"
  if (action === "accepter") {
    location.annonce.statut = "reserve"; // Par exemple : "disponible" ou "reserve"
    await location.annonce.save();
  }

  res.status(200).json({
    status: "succÃ¨s",
    message: `La demande a Ã©tÃ© ${action === "accepter" ? "acceptÃ©e" : "refusÃ©e"}.`,
    data: location,
  });
});


// Liste toutes les locations sur la plateforme
export const listerLocations = catchAsync(async (req, res, next) => {
  // RÃ©cupÃ¨re toutes les locations et Â« populate Â» les champs liÃ©s (comme vÃ©hicule, locataire et propriÃ©taire)
  const locations = await Location.find();

  res.status(200).json({
    status: "succes",
    data: locations,
  });
});

export const detailLocation = catchAsync(async (req, res, next) => {
  const location = await Location.findById(req.params.id);

  if (!location) return next(new AppError("Location non trouvÃ©e", 404));
  res.status(200).json({ status: "succes", data: location });
});

// Validation de la reservation par le proprietaire

export const validerLocation = catchAsync(async (req, res, next) => {
  const location = await Location.findById(req.params.id);

  if (!location) return next(new AppError("Location non trouvÃ©", 404));

  if (location.proprietaire.toString() !== req.user._id.toString())
    return next(new AppError("Acces refusÃ©"), 403);

  location.status = "validÃ©e";

  await location.save();

  res.status(200).json({ status: "succes", message: "Location validÃ©e" });
});

// Marquer la reservation comme payÃ©e (apres paiement rÃ©ussi)

export const marquerCommePayer = catchAsync(async (req, res, next) => {
  const { locationId } = req.body;

  const location = await Location.findById(locationId);
  if (!location) return next(new AppError("Location non trouvÃ©e", 404));

  if (location.proprietaire.toString() !== req.user._id.toString())
    return next(new AppError("Acces refusÃ©", 403));

  location.status = "payÃ©e";
  await location.save();

  res
    .status(200)
    .json({ status: "succes", message: "Paiement validÃ©, location payÃ©e." });
});

// GET /api/locations/mes-reservations
export const listerMesReservations = catchAsync(async (req, res, next) => {
  const locations = await Location.find({ locataire: req.user._id })
    .populate({
      path: "annonce",
      populate: {
        path: "voiture",
      },
    })
    .sort({ dateDebut: -1 });

  res.status(200).json({
    status: "succÃ¨s",
    rÃ©sultats: locations.length,
    data: locations,
  });
});

// DELETE /api/locations/:id/annuler
export const annulerReservation = catchAsync(async (req, res, next) => {
  const location = await Location.findById(req.params.id).populate("annonce");

  if (!location) {
    return next(new AppError("RÃ©servation non trouvÃ©e", 404));
  }

  // VÃ©rifie que câ€™est bien le locataire
  if (location.locataire.toString() !== req.user._id.toString()) {
    return next(
      new AppError("Vous n'avez pas le droit d'annuler cette rÃ©servation", 403)
    );
  }

  // (Optionnel) Ne pas annuler si dÃ©jÃ  validÃ©e
  if (location.statut === "acceptÃ©e") {
    return next(
      new AppError("Impossible d'annuler une rÃ©servation dÃ©jÃ  acceptÃ©e", 400)
    );
  }

  await location.deleteOne();

  res.status(200).json({
    status: "succÃ¨s",
    message: "RÃ©servation annulÃ©e",
  });
});

// GET /api/locations/mes-demandes
export const listerDemandesSurMesAnnonces = catchAsync(
  async (req, res, next) => {
    // On cherche les annonces de ce propriÃ©taire
    const mesAnnonces = await Annonce.find(
      { proprietaire: req.user._id },
      "_id"
    );
    const mesAnnonceIds = mesAnnonces.map((a) => a._id);

    // On rÃ©cupÃ¨re toutes les rÃ©servations liÃ©es
    const demandes = await Location.find({ annonce: { $in: mesAnnonceIds } })
      .populate("locataire", "nom email")
      .populate({
        path: "annonce",
        populate: {
          path: "voiture",
        },
      })
      .sort({ createdAt: -1 });

    res.status(200).json({
      status: "succÃ¨s",
      rÃ©sultats: demandes.length,
      data: demandes,
    });
  }
);


//  lister les reservations d'un utilisateur
// export const listerMesRÃ©servations = catchAsync(async (req, res, next) => {
//   // On cherche les annonces de ce propriÃ©taire
//   const mesAnnonces = await Annonce.find(
//     { proprietaire: req.user._id },
//     "_id"
//   );
//   const mesAnnonceIds = mesAnnonces.map((a) => a._id);
//   // On rÃ©cupÃ¨re toutes les rÃ©servations liÃ©es
//   const demandes = await Location.find({ annonce: { $in: mesAnnonceIds } })
//     .populate("locataire", "nom email")
//     .populate({
//       path: "annonce",
//       populate: {
//         path: "voiture",
//       },
//     })
//     .sort({ createdAt: -1 });
//   res.status(200).json({
//     status: "succÃ¨s",
//     rÃ©sultats: demandes.length,
//     data: demandes,
//   });
// });
//  lister les reservations d'un utilisateur


export const mettreAJourStatutLocation = catchAsync(async (req, res, next) => {
  const location = await Location.findById(req.params.id)
    .populate('annonce')
    .populate('locataire');

  if (!location) {
    return next(new AppError('RÃ©servation introuvable', 404));
  }

  // VÃ©rification des autorisations
  const isProprietaire = location.annonce.proprietaire.toString() === req.user._id.toString();
  const isLocataire = location.locataire._id.toString() === req.user._id.toString();

  if (!isProprietaire && !isLocataire) {
    return next(new AppError('Action non autorisÃ©e', 403));
  }

  // Logique de transition d'Ã©tat
  const nouvelEtat = req.body.etat;
  const etatsAutorises = ['terminee', 'annulee'];
  
  if (!etatsAutorises.includes(nouvelEtat)) {
    return next(new AppError('Ã‰tat de rÃ©servation invalide', 400));
  }

  // Validation des transitions
  if (nouvelEtat === 'terminee' && !isProprietaire) {
    return next(new AppError('Seul le propriÃ©taire peut terminer une rÃ©servation', 403));
  }

  if (nouvelEtat === 'annulee') {
    const maintenant = new Date();
    if (maintenant > location.dateDebut) {
      return next(new AppError('Annulation impossible aprÃ¨s la date de dÃ©but', 400));
    }
  }

  // Mise Ã  jour de la rÃ©servation
  location.statut = nouvelEtat;
  await location.save();

  // RÃ©activation de l'annonce si nÃ©cessaire
  if (['terminee', 'annulee'].includes(nouvelEtat)) {
    location.annonce.statut = 'disponible';
    await location.annonce.save();

    // Optionnel : Remboursement partiel si annulation
    if (nouvelEtat === 'annulee') {
      await effectuerRemboursement(location);
    }
  }

  res.status(200).json({
    status: 'success',
    message: `RÃ©servation ${nouvelEtat === 'terminee' ? 'terminÃ©e' : 'annulÃ©e'} avec succÃ¨s`,
    data: {
      location
    }
  });
});



// Consulter le dÃ©tail d'une location par le locataire
export const consulterDetailLocationLocataire = catchAsync(async (req, res, next) => {
  const location = await Location.findById(req.params.id)
    .populate({
      path: "annonce",
      populate: { path: "voiture", populate: { path: "proprietaire" } },
    })
    .populate("locataire", "nom email");

  if (!location) {
    return next(new AppError("Location non trouvÃ©e", 404));
  }

  // VÃ©rifie que le locataire est bien celui connectÃ©
  if (location.locataire._id.toString() !== req.user._id.toString()) {
    return next(new AppError("AccÃ¨s non autorisÃ©", 403));
  }

  res.status(200).json({
    status: "succÃ¨s",
    data: location,
  });
});

// // Fonction helper pour le remboursement
// const effectuerRemboursement = async (location) => {
//   // ImplÃ©mentez votre logique de remboursement Stripe ici
//   // Exemple simplifiÃ© :
//   /*
//   if (location.paiementId) {
//     await stripe.refunds.create({
//       payment_intent: location.paiementId,
//       amount: Math.floor(location.montantTotal * 0.8) // 80% de remboursement
//     });
//   }
//   */
// };
